/// <reference types="node" />
/// <reference types="webpack-env" />
import { Logger } from 'winston';
import { ErrorRequestHandler, RequestHandler, Router } from 'express';
import { ConfigReader } from '@backstage/config';
import cors from 'cors';
import { Server } from 'http';

declare class CustomErrorBase extends Error {
    readonly cause?: Error;
    constructor(message?: string, cause?: Error);
}
/**
 * The given inputs are malformed and cannot be processed.
 */
declare class InputError extends CustomErrorBase {
}
/**
 * The request requires authentication, which was not properly supplied.
 */
declare class AuthenticationError extends CustomErrorBase {
}
/**
 * The authenticated caller is not allowed to perform this request.
 */
declare class NotAllowedError extends CustomErrorBase {
}
/**
 * The requested resource could not be found.
 *
 * Note that this error usually is used to indicate that an entity with a given
 * ID does not exist, rather than signalling that an entire route is missing.
 */
declare class NotFoundError extends CustomErrorBase {
}
/**
 * The request could not complete due to a conflict in the current state of the
 * resource.
 */
declare class ConflictError extends CustomErrorBase {
}

declare function getRootLogger(): Logger;
declare function setRootLogger(newLogger: Logger): void;

/**
 * A logger that just throws away all messages.
 */
declare function getVoidLogger(): Logger;

declare type ErrorHandlerOptions = {
    /**
     * Whether error response bodies should show error stack traces or not.
     *
     * If not specified, by default shows stack traces only in development mode.
     */
    showStackTraces?: boolean;
};
/**
 * Express middleware to handle errors during request processing.
 *
 * This is commonly the very last middleware in the chain.
 *
 * Its primary purpose is not to do translation of business logic exceptions,
 * but rather to be a gobal catch-all for uncaught "fatal" errors that are
 * expected to result in a 500 error. However, it also does handle some common
 * error types (such as http-error exceptions) and returns the enclosed status
 * code accordingly.
 *
 * @returns An Express error request handler
 */
declare function errorHandler(options?: ErrorHandlerOptions): ErrorRequestHandler;

/**
 * Express middleware to handle requests for missing routes.
 *
 * Should be used as the very last handler in the chain, as it unconditionally
 * returns a 404 status.
 *
 * @returns An Express request handler
 */
declare function notFoundHandler(): RequestHandler;

/**
 * Logs incoming requests.
 *
 * @param logger An optional logger to use. If not specified, the root logger will be used.
 * @returns An Express request handler
 */
declare function requestLoggingHandler(logger?: Logger): RequestHandler;

declare type ServiceBuilder = {
    /**
     * Sets the service parameters based on configuration.
     *
     * @param config The configuration to read
     */
    loadConfig(config: ConfigReader): ServiceBuilder;
    /**
     * Sets the port to listen on.
     *
     * If no port is specified, the service will first look for an environment
     * variable named PORT and use that if present, otherwise it picks a default
     * port (7000).
     *
     * @param port The port to listen on
     */
    setPort(port: number): ServiceBuilder;
    /**
     * Sets the logger to use for service-specific logging.
     *
     * If no logger is given, the default root logger is used.
     *
     * @param logger A winston logger
     */
    setLogger(logger: Logger): ServiceBuilder;
    /**
     * Enables CORS handling using the given settings.
     *
     * If this method is not called, the resulting service will not have any
     * built in CORS handling.
     *
     * @param options Standard CORS options
     */
    enableCors(options: cors.CorsOptions): ServiceBuilder;
    /**
     * Adds a router (similar to the express .use call) to the service.
     *
     * @param root The root URL to bind to (e.g. "/api/function1")
     * @param router An express router
     */
    addRouter(root: string, router: Router): ServiceBuilder;
    /**
     * Starts the server using the given settings.
     */
    start(): Promise<Server>;
};

declare class ServiceBuilderImpl implements ServiceBuilder {
    private port;
    private host;
    private logger;
    private corsOptions;
    private routers;
    private module;
    constructor(moduleRef: NodeModule);
    loadConfig(config: ConfigReader): ServiceBuilder;
    setPort(port: number): ServiceBuilder;
    setHost(host: string): ServiceBuilder;
    setLogger(logger: Logger): ServiceBuilder;
    enableCors(options: cors.CorsOptions): ServiceBuilder;
    addRouter(root: string, router: Router): ServiceBuilder;
    start(): Promise<Server>;
    private getOptions;
}

/**
 * Creates a new service builder.
 */
declare function createServiceBuilder(_module: NodeModule): ServiceBuilderImpl;



/**
 * useHotCleanup allows cleanup of ongoing effects when a module is
 * hot-reloaded during development. The cleanup function will be called
 * whenever the module itself or any of its parent modules is hot-reloaded.
 *
 * Useful for cleaning intervals, timers, requests etc
 *
 * @example
 * ```ts
 * const intervalId = setInterval(doStuff, 1000);
 * useHotCleanup(module, () => clearInterval(intervalId));
 * ```
 * @param _module Reference to the current module where you invoke the fn
 * @param cancelEffect Fn that cleans up the ongoing effects
 */
declare function useHotCleanup(_module: NodeModule, cancelEffect: () => void): void;
/**
 * Memoizes a generated value across hot-module reloads. This is useful for
 * stateful parts of the backend, e.g. to retain a database.
 *
 * @example
 * ```ts
 * const db = useHotMemoize(module, () => createDB(dbParams));
 * ```
 *
 * @warning Don't use inside conditionals or loops,
 * same rules as for hooks apply (https://reactjs.org/docs/hooks-rules.html)
 *
 * @param _module Reference to the current module where you invoke the fn
 * @param valueFactory Fn that returns the value you want to memoize
 */
declare function useHotMemoize<T>(_module: NodeModule, valueFactory: () => T): T;

export { AuthenticationError, ConflictError, ErrorHandlerOptions, InputError, NotAllowedError, NotFoundError, ServiceBuilder, createServiceBuilder, errorHandler, getRootLogger, getVoidLogger, notFoundHandler, requestLoggingHandler, setRootLogger, useHotCleanup, useHotMemoize };
