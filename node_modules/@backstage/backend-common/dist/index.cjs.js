'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var winston = require('winston');
var stream = require('stream');
var morgan2 = _interopDefault(require('morgan'));
var compression2 = _interopDefault(require('compression'));
var cors2 = _interopDefault(require('cors'));
var express2 = _interopDefault(require('express'));
var helmet2 = _interopDefault(require('helmet'));
var stoppable2 = _interopDefault(require('stoppable'));

class CustomErrorBase extends Error {
  constructor(message, cause) {
    let fullMessage = message;
    if (cause) {
      if (fullMessage) {
        fullMessage += `; caused by ${cause}`;
      } else {
        fullMessage = `caused by ${cause}`;
      }
    }
    super(fullMessage);
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.cause = cause;
  }
}
class InputError extends CustomErrorBase {
}
class AuthenticationError extends CustomErrorBase {
}
class NotAllowedError extends CustomErrorBase {
}
class NotFoundError extends CustomErrorBase {
}
class ConflictError extends CustomErrorBase {
}

let rootLogger = winston.createLogger({
  level: process.env.LOG_LEVEL || "info",
  format: process.env.NODE_ENV === "production" ? winston.format.json() : winston.format.combine(winston.format.colorize(), winston.format.timestamp(), winston.format.simple()),
  defaultMeta: {service: "backstage"},
  transports: [
    new winston.transports.Console({
      silent: process.env.JEST_WORKER_ID !== void 0 && !process.env.LOG_LEVEL
    })
  ]
});
function getRootLogger() {
  return rootLogger;
}
function setRootLogger(newLogger) {
  rootLogger = newLogger;
}

function getVoidLogger() {
  return winston.createLogger({
    transports: [new winston.transports.Stream({stream: new stream.PassThrough()})]
  });
}

function errorHandler(options = {}) {
  var _a;
  const showStackTraces = (_a = options.showStackTraces) != null ? _a : process.env.NODE_ENV === "development";
  return (error, _request, response, next) => {
    if (response.headersSent) {
      next(error);
      return;
    }
    const status = getStatusCode(error);
    const message = showStackTraces ? error.stack : error.message;
    response.status(status).send(message);
  };
}
function getStatusCode(error) {
  const knownStatusCodeFields = ["statusCode", "status"];
  for (const field of knownStatusCodeFields) {
    const statusCode = error[field];
    if (typeof statusCode === "number" && (statusCode | 0) === statusCode && statusCode >= 100 && statusCode <= 599) {
      return statusCode;
    }
  }
  switch (error.name) {
    case InputError.name:
      return 400;
    case AuthenticationError.name:
      return 401;
    case NotAllowedError.name:
      return 403;
    case NotFoundError.name:
      return 404;
    case ConflictError.name:
      return 409;
  }
  return 500;
}

function notFoundHandler() {
  return (_request, response, _next) => {
    response.status(404).send();
  };
}

function requestLoggingHandler(logger) {
  const actualLogger = (logger || getRootLogger()).child({
    type: "incomingRequest"
  });
  return morgan2("combined", {
    stream: {
      write(message) {
        actualLogger.info(message);
      }
    }
  });
}

function findAllAncestors(_module) {
  const ancestors = new Array();
  const parentIds = new Set();
  function add(id, m) {
    if (parentIds.has(id)) {
      return;
    }
    parentIds.add(id);
    ancestors.push(m);
    for (const parentId of m.parents) {
      const parent = require.cache[parentId];
      if (parent) {
        add(parentId, parent);
      }
    }
  }
  add(_module.id, _module);
  return ancestors;
}
function useHotCleanup(_module, cancelEffect) {
  var _a;
  if (_module.hot) {
    const ancestors = findAllAncestors(_module);
    let cancelled = false;
    const handler = () => {
      if (!cancelled) {
        cancelled = true;
        cancelEffect();
      }
    };
    for (const m of ancestors) {
      (_a = m.hot) == null ? void 0 : _a.addDisposeHandler(handler);
    }
  }
}
const CURRENT_HOT_MEMOIZE_INDEX_KEY = "backstage.io/hmr-memoize-key";
function useHotMemoize(_module, valueFactory) {
  var _a, _b, _c;
  if (!_module.hot) {
    return valueFactory();
  }
  if (!((_a = _module.hot.data) == null ? void 0 : _a[CURRENT_HOT_MEMOIZE_INDEX_KEY])) {
    for (const ancestor of findAllAncestors(_module)) {
      (_b = ancestor.hot) == null ? void 0 : _b.addDisposeHandler((data) => {
        data[CURRENT_HOT_MEMOIZE_INDEX_KEY] = 1;
      });
    }
    _module.hot.data = {
      ..._module.hot.data,
      [CURRENT_HOT_MEMOIZE_INDEX_KEY]: 1
    };
  }
  const index = _module.hot.data[CURRENT_HOT_MEMOIZE_INDEX_KEY]++;
  const value = (_c = _module.hot.data[index]) != null ? _c : valueFactory();
  _module.hot.addDisposeHandler((data) => {
    data[index] = value;
  });
  return value;
}

function readBaseOptions(config2) {
  const {host, port} = parseListenAddress(config2.getString("listen"));
  return removeUnknown({
    listenPort: port,
    listenHost: host
  });
}
function readCorsOptions(config2) {
  const cc = config2.getOptionalConfig("cors");
  if (!cc) {
    return void 0;
  }
  return removeUnknown({
    origin: getOptionalStringOrStrings(cc, "origin"),
    methods: getOptionalStringOrStrings(cc, "methods"),
    allowedHeaders: getOptionalStringOrStrings(cc, "allowedHeaders"),
    exposedHeaders: getOptionalStringOrStrings(cc, "exposedHeaders"),
    credentials: cc.getOptionalBoolean("credentials"),
    maxAge: cc.getOptionalNumber("maxAge"),
    preflightContinue: cc.getOptionalBoolean("preflightContinue"),
    optionsSuccessStatus: cc.getOptionalNumber("optionsSuccessStatus")
  });
}
function getOptionalStringOrStrings(config2, key) {
  const value = config2.getOptional(key);
  if (value === void 0 || typeof value === "string" || isStringArray(value)) {
    return value;
  }
  throw new Error(`Expected string or array of strings, got ${typeof value}`);
}
function isStringArray(value) {
  if (!Array.isArray(value)) {
    return false;
  }
  for (const v of value) {
    if (typeof v !== "string") {
      return false;
    }
  }
  return true;
}
function removeUnknown(obj) {
  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== void 0));
}
function parseListenAddress(value) {
  const parts = value.split(":");
  if (parts.length === 1) {
    return {port: parseInt(parts[0], 10)};
  }
  if (parts.length === 2) {
    return {host: parts[0], port: parseInt(parts[1], 10)};
  }
  throw new Error(`Unable to parse listen address ${value}, expected <port> or <host>:<port>`);
}

const DEFAULT_PORT = 7e3;
const DEFAULT_HOST = "localhost";
class ServiceBuilderImpl {
  constructor(moduleRef) {
    this.routers = [];
    this.module = moduleRef;
  }
  loadConfig(config3) {
    const backendConfig = config3.getOptionalConfig("backend");
    if (!backendConfig) {
      return this;
    }
    const baseOptions = readBaseOptions(backendConfig);
    if (baseOptions.listenPort) {
      this.port = baseOptions.listenPort;
    }
    if (baseOptions.listenHost) {
      this.host = baseOptions.listenHost;
    }
    const corsOptions = readCorsOptions(backendConfig);
    if (corsOptions) {
      this.corsOptions = corsOptions;
    }
    return this;
  }
  setPort(port) {
    this.port = port;
    return this;
  }
  setHost(host) {
    this.host = host;
    return this;
  }
  setLogger(logger) {
    this.logger = logger;
    return this;
  }
  enableCors(options) {
    this.corsOptions = options;
    return this;
  }
  addRouter(root, router) {
    this.routers.push([root, router]);
    return this;
  }
  start() {
    const app = express2();
    const {port, host, logger, corsOptions} = this.getOptions();
    app.use(helmet2());
    if (corsOptions) {
      app.use(cors2(corsOptions));
    }
    app.use(compression2());
    app.use(express2.json());
    app.use(requestLoggingHandler());
    for (const [root, route] of this.routers) {
      app.use(root, route);
    }
    app.use(notFoundHandler());
    app.use(errorHandler());
    return new Promise((resolve, reject) => {
      app.on("error", (e) => {
        logger.error(`Failed to start up on port ${port}, ${e}`);
        reject(e);
      });
      const server = stoppable2(app.listen(port, host, () => {
        logger.info(`Listening on ${host}:${port}`);
      }), 0);
      useHotCleanup(this.module, () => server.stop((e) => {
        if (e)
          console.error(e);
      }));
      resolve(server);
    });
  }
  getOptions() {
    var _a, _b, _c;
    return {
      port: (_a = this.port) != null ? _a : DEFAULT_PORT,
      host: (_b = this.host) != null ? _b : DEFAULT_HOST,
      logger: (_c = this.logger) != null ? _c : getRootLogger(),
      corsOptions: this.corsOptions
    };
  }
}

function createServiceBuilder(_module) {
  return new ServiceBuilderImpl(_module);
}

exports.AuthenticationError = AuthenticationError;
exports.ConflictError = ConflictError;
exports.InputError = InputError;
exports.NotAllowedError = NotAllowedError;
exports.NotFoundError = NotFoundError;
exports.createServiceBuilder = createServiceBuilder;
exports.errorHandler = errorHandler;
exports.getRootLogger = getRootLogger;
exports.getVoidLogger = getVoidLogger;
exports.notFoundHandler = notFoundHandler;
exports.requestLoggingHandler = requestLoggingHandler;
exports.setRootLogger = setRootLogger;
exports.useHotCleanup = useHotCleanup;
exports.useHotMemoize = useHotMemoize;
